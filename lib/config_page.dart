import 'dart:convert';
import 'dart:ffi';
import 'dart:io';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';
import 'dart:ui';
import 'dart:async';
import 'package:shop_pro/font_sizes.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:shop_pro/secureStorage.dart';
import 'package:shop_pro/speech.dart';
import 'aes.dart';
import 'api_services.dart';
import 'db_operations.dart';
import 'logger.dart';
import 'login_page.dart';
import 'model_api_config.dart';
import 'dart:math' as math;
import 'package:package_info_plus/package_info_plus.dart';
import 'package:crypto/crypto.dart';
import 'package:flutter/cupertino.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class ConfigPage extends StatefulWidget {
  @override
  _WelcomePageState createState() => _WelcomePageState();
}

class _WelcomePageState extends State<ConfigPage>
    with SingleTickerProviderStateMixin {
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();
  static const String fontFamily = 'Lato';
  TextEditingController ipAddressController = TextEditingController();
  TextEditingController portNoController = TextEditingController();
  TextEditingController clientIDController = TextEditingController();
  TextEditingController activationController = TextEditingController();
  FocusNode? _focusNodeIp;
  FocusNode? _focusNodePort;
  FocusNode? _focusNodeClientID;
  FocusNode? _focusNodeActivation;
  String? _selectedCurrency;
  List<String> currencyCodes = [
    'BHD', // Bahraini Dinar
    'KWD', // Kuwaiti Dinar
    'OMR', // Omani Rial
    'QAR', // Qatari Riyal
    'SAR', // Saudi Riyal
    'AED', // UAE Dirham
  ];
  String? _selectedVoice;
  List<String> voiceCodes = [
    'VOICE1',
    'VOICE2',
    'VOICE3',
    'VOICE4',
  ];
  bool _imgScrollCheck = false;
  bool _videoScrollCheck = false;
  bool _textScrollCheck = false;
  bool _logoCheck = false;
  bool _bannerCheck = false;
  String _selectedScrollOption =
      'IMAGE'; // Default selected option for the group
  late var fontSizes;
  final ScrollController scrollController = ScrollController();
  String statusMsg = '';
  List<String> statusMessages = [];
  Timer? _timer;
  late AnimationController animationController;
  final ScrollController _scrollController = ScrollController();
  // final ApiHelper _apiHelper = ApiHelper();
  bool actRandom = false; // TO indicate that the activation code is generated by random function or system serial number.
  bool actStatus = false; // TO indicate that the activation code is generated by random function or system serial number.
  final dbProvider = DBProvider.db;
  ApiDataModel apiData = ApiDataModel(//TODO
    serverIP: '',
    portNo: '',
    currency: '',
    voice: '',
    clientID: '',
    actCode: '',
    actKey: '',
    actAllow: '',
    actStatus: '',
    logoEnable: '',
    bannerEnable: '',
    imageScroll: '',
    priceDisplay: '',
    imageDisplay: '',
    videoScroll: '',
    textScroll: '',
    dateTime: '',
  );
  int _imgScrollDuration = 5; // Initial count
  int _priceDisplayDuration = 3; // Initial count
  bool registerAllow = true;
  late ApiHelper _apiHelper;
  final String IV = 'bQ8zNpD4WjX7K9Lm';
  final Map<String, String> formData = {
    'clientID': '',
    'actCode': '',
  };
  late String appVersion = '';
  bool isGenerated = false;
  bool writeToServer = false;
  final priceSpeaker = PriceSpeaker();
  final SecureStorageService _secureStorageService = SecureStorageService();
  bool secureStorageFlag = false;
  String secureStorageclientID = '';
  String secureStorageactCode = '';


  @override
  initState() {
    super.initState();
    animationController = AnimationController(duration: const Duration(seconds: 2), vsync: this);
    animationController.repeat();
    _focusNodeIp = FocusNode();
    _focusNodePort = FocusNode();
    _initializeApp();
  }

  @override
  void dispose() {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.manual, overlays: []);
    scrollController.dispose();
    _scrollController.dispose();
    _timer?.cancel();
    ipAddressController.dispose();
    portNoController.dispose();
    clientIDController.dispose();
    activationController.dispose();
    _focusNodeIp?.dispose();
    _focusNodePort?.dispose();
    _focusNodeClientID?.dispose();
    _focusNodeActivation?.dispose();
    animationController.dispose(); // Properly dispose of the AnimationController
    super.dispose();
  }

  void _initializeApp() async {
    await _getSecureStorageData();
    await _getAppVersion();
    await _loadDbData();
    _hideSystemBars();
  }

  Future<void> _getSecureStorageData() async {
    // Retrieve clientID and actCode from secure storage
    var clientID = await _secureStorageService.readData('clientID');
    var actCode = await _secureStorageService.readData('actCode');
    // Check if clientID and actCode are non-null and non-empty, and update variables accordingly
    secureStorageclientID = (clientID != null && clientID.isNotEmpty) ? clientID : '';
    secureStorageactCode = (actCode != null && actCode.isNotEmpty) ? actCode : '';
    Logger.log('DATA FROM SECURE STORAGE => secureStorageclientID = $secureStorageclientID secureStorageactCode = $secureStorageactCode', level: LogLevel.critical);
    // Set secureStorageFlag based on whether both values are valid
    secureStorageFlag = secureStorageclientID.isNotEmpty && secureStorageactCode.isNotEmpty;
  }

  void _clearControllers() {
    setState(() {
      ipAddressController.clear();
      portNoController.clear();
      clientIDController.clear();
      activationController.clear();
    });
  }

  void _hideSystemBars() {
    // Hides both the status bar and the navigation bar
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);
    // Optional: Make the system navigation bar and status bar transparent
    SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      systemNavigationBarColor: Colors.transparent,
    ));
  }

  Widget _title() {
    return RichText(
      textAlign: TextAlign.center,
      text: TextSpan(
          text: 'S',
          style: GoogleFonts.portLligatSans(
            textStyle: Theme.of(context).textTheme.bodyLarge,
            fontSize: fontSizes.largerFontSize10,
            fontWeight: FontWeight.w700,
            color: Colors.redAccent,
          ),
          children: [
            TextSpan(
              text: 'ystem',
              style: TextStyle(
                  color: Colors.black,
                  fontSize: fontSizes.largerFontSize9,
                  fontWeight: FontWeight.w900),
            ),
            TextSpan(
              text: ' C',
              style: TextStyle(
                  color: Colors.blueAccent,
                  fontSize: fontSizes.largerFontSize10,
                  fontWeight: FontWeight.w900),
            ),
            TextSpan(
              text: 'onfig',
              style: TextStyle(
                  color: Colors.black, fontSize: fontSizes.largerFontSize9),
            ),
          ]),
    );
  }

  Widget _ipAddress() {
    return Container(
      width: MediaQuery.of(context).size.width / 2.5,
      height: 50,
      alignment: Alignment.center,
      child: TextFormField(
        keyboardType: const TextInputType.numberWithOptions(decimal: true),
        inputFormatters: [
          FilteringTextInputFormatter.allow(RegExp(r'[0-9.]')),
          LengthLimitingTextInputFormatter(15),
        ],
        onEditingComplete: () {
          FocusScope.of(context).requestFocus(_focusNodePort);
        },
        textAlign: TextAlign.left,
        focusNode: _focusNodeIp,
        autofocus: true,
        obscureText: false,
        controller: ipAddressController,
        style: TextStyle(
            fontSize: fontSizes.baseFontSize, height: 1, color: Colors.black),
        decoration: InputDecoration(
          isDense: true,
          prefixIcon: Padding(
            padding: const EdgeInsets.only(left: 0),
            child: Icon(
              Icons.lan,
              size: fontSizes.largerFontSize4,
              color: Colors.blue,
            ),
          ),
          suffixIcon: IconButton(
            icon: const Icon(
              Icons.close, // X icon
              color: Colors.black,
            ),
            onPressed: () {
              ipAddressController.clear(); // Clear the text field
            },
          ),
          fillColor: Colors.black,
          border: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.black, width: 5.00),
            borderRadius: BorderRadius.circular(2.0),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.blue),
            borderRadius: BorderRadius.circular(2.0),
          ),
          labelText: ' IP ADDRESS',
          labelStyle:
              TextStyle(color: Colors.black, fontSize: fontSizes.baseFontSize),
        ),
        validator: validateIpAddress, // Add the validator here
      ),
    );
  }

  Widget _portNo() {
    return Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        child: TextFormField(
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9]')),
              LengthLimitingTextInputFormatter(6),
            ],
            onEditingComplete: () => FocusScope.of(context).nextFocus(),
            textAlign: TextAlign.left,
            focusNode: _focusNodePort,
            autofocus: true,
            obscureText: false,
            controller: portNoController,
            style: TextStyle(
                fontSize: fontSizes.baseFontSize,
                height: 1,
                color: Colors.black),
            decoration: InputDecoration(
              isDense: true,
              prefixIcon: Padding(
                padding: EdgeInsets.only(left: 0),
                child: Icon(
                  Icons.private_connectivity,
                  size: fontSizes.largerFontSize4,
                  color: Colors.blue,
                ),
              ),
              suffixIcon: IconButton(
                icon: const Icon(
                  Icons.close, // X icon
                  color: Colors.black,
                ),
                onPressed: () {
                  portNoController.clear(); // Clear the text field
                },
              ),
              fillColor: Colors.white,
              border: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.black, width: 5.00),
                borderRadius: BorderRadius.circular(2.0),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.blue),
                borderRadius: BorderRadius.circular(2.0),
              ),
              labelText: ' PORT NO',
              labelStyle: TextStyle(
                  color: Colors.black, fontSize: fontSizes.baseFontSize),
            )));
  }

  Widget _testButton() {
    return InkWell(
      onTap: () async {
        if((ipAddressController.text!=null && portNoController!=null) && (ipAddressController.text!='' && portNoController!='')) {
          _apiHelper = ApiHelper();
          _addStatusMessage('CONNECTING TO SERVER...');
          _apiHelper.initializeDio(ipAddressController.text, portNoController.text);
          if(await _apiHelper.testConnectivity()){
            _addStatusMessage('SERVER CONNECTED...');
          }else{
            _addStatusMessage('SERVER CONNECTION FAILED...');
          }
          //TODO
          // _apiHelper.updateBaseUrl(
          //     ipAddressController.text, portNoController.text);
          // try {
          //   if (await _apiHelper.testConnectivity()) {
          //     _addStatusMessage('SERVER CONNECTION SUCCESS...');
          //   } else {
          //     _addStatusMessage('SERVER CONNECTION FAILURE...');
          //   }
          // } catch (e) {
          //   _addStatusMessage('SERVER CONNECTION FAILURE...');
          // }
        }else{
          _addStatusMessage('ENTER VALID SERVER DETAILS...');
        }
      },
      child: Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        decoration: const BoxDecoration(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          color: Colors.red,
        ),
        child: Text(
          'TEST',
          style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              color: Colors.black), // Adjusted font size to match others
        ),
      ),
    );
  }

  Widget _saveButton() {
    return InkWell(
      onTap: () async {
        if(await saveData()){
          _loadDbData();
          if(apiData.actStatus=='true') {
            Navigator.pushReplacement(
              context,
              MaterialPageRoute(builder: (context) => LoginPage()),
            );
          }else{
            _addStatusMessage('PLEASE REGISTER TERMINAL AND PROCEED...');
          }
        }else{

        }
      },
      child: Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        decoration: const BoxDecoration(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          color: Colors.blueAccent,
        ),
        child: Text(
          'SAVE',
          style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              color: Colors.black), // Adjusted font size to match others
        ),
      ),
    );
  }

  Widget _currencyDropdown() {
    return Container(
      width: MediaQuery.of(context).size.width / 2.5,
      height: 50,
      alignment: Alignment.center,
      child: DropdownButtonFormField<String>(
        value: _selectedCurrency,
        items: currencyCodes.map((String currency) {
          return DropdownMenuItem<String>(
            value: currency,
            child: Center(
              child: Text(currency,
                  textAlign: TextAlign.center), // Centering the text
            ),
          );
        }).toList(),
        onChanged: (String? newValue) {
          setState(() {
            _selectedCurrency = newValue;
          });
        },
        decoration: InputDecoration(
          isDense: true,
          prefixIcon: Padding(
            padding: EdgeInsets.only(left: 0),
            child: Icon(
              Icons.money,
              size: fontSizes.largerFontSize4,
              color: Colors.blue,
            ),
          ),
          fillColor: Colors.black,
          border: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.black, width: 5.00),
            borderRadius: BorderRadius.circular(2.0),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.blue),
            borderRadius: BorderRadius.circular(2.0),
          ),
          labelText: 'CURRENCY',
          labelStyle: TextStyle(
            color: Colors.black,
            fontSize: fontSizes.baseFontSize,
          ),
        ),
        style: TextStyle(
            fontSize: fontSizes.baseFontSize, height: 1, color: Colors.black),
      ),
    );
  }

  Widget _voiceDropdown() {
    return Container(
      width: MediaQuery.of(context).size.width / 2.5,
      height: 50,
      alignment: Alignment.center,
      child: DropdownButtonFormField<String>(
        value: _selectedVoice,
        items: voiceCodes.map((String currency) {
          return DropdownMenuItem<String>(
            value: currency,
            child: Center(
              child: Text(currency,
                  textAlign: TextAlign.center), // Centering the text
            ),
          );
        }).toList(),
        onChanged: (String? newValue) {
          setState(() {
            _selectedVoice = newValue;
          });
        },
        decoration: InputDecoration(
          isDense: true,
          prefixIcon: Padding(
            padding: EdgeInsets.only(left: 0),
            child: Icon(
              Icons.mic,
              size: fontSizes.largerFontSize4,
              color: Colors.blue,
            ),
          ),
          fillColor: Colors.black,
          border: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.black, width: 5.00),
            borderRadius: BorderRadius.circular(2.0),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.blue),
            borderRadius: BorderRadius.circular(2.0),
          ),
          labelText: 'VOICE',
          labelStyle: TextStyle(
            color: Colors.black,
            fontSize: fontSizes.baseFontSize,
          ),
        ),
        style: TextStyle(
            fontSize: fontSizes.baseFontSize, height: 1, color: Colors.black),
      ),
    );
  }

  Widget _initButton() {
    return InkWell(
      onTap: () async {

        _addStatusMessage('INIT BUTTON PRESSED');
      },
      child: Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        decoration: const BoxDecoration(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          color: Colors.lightGreen,
        ),
        child: Text(
          'INIT',
          style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              color: Colors.black), // Adjusted font size to match others
        ),
      ),
    );
  }

  Widget _resetButton() {
    return InkWell(
      onTap: () async {
        await showCupertinoDialog(
          context: context,
          builder: (BuildContext context) {
            return CupertinoAlertDialog(
              title: const Text('APPLICATION RESET'),
              content: const Text(
                  'All application data, including activation details, will be permanently erased. '
                      'This action cannot be undone.\n\nDo you wish to continue?'
              ),
              actions: [
                CupertinoDialogAction(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: Text('No'),
                ),
                CupertinoDialogAction(
                  onPressed: () async{
                    try {
                      if(await dbProvider.deleteApiData()) {
                        _addStatusMessage('DATABASE DELETION IS IN PROGRESS.');
                        _clearControllers();
                      }else{
                        _addStatusMessage('DATABASE DELETION FAILURE.');
                      }
                    }catch (e){
                      _addStatusMessage('ERROR DELETING DB.\n${e.toString()}');
                    }
                    Navigator.of(context).pop(); // Close the dialog
                  },
                  child: Text('Yes'),
                ),
              ],
            );
          },
        );
      },
      child: Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        decoration: const BoxDecoration(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          color: Colors.orange,
        ),
        child: Text(
          'RESET',
          style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              color: Colors.black), // Adjusted font size to match others
        ),
      ),
    );
  }

  Widget _clientID() {
    return Container(
      width: MediaQuery.of(context).size.width / 2.5,
      height: 50,
      alignment: Alignment.center,
      child: TextFormField(
        keyboardType: const TextInputType.numberWithOptions(decimal: true),
        inputFormatters: [
          LengthLimitingTextInputFormatter(15),
        ],
        onEditingComplete: () {
          FocusScope.of(context).requestFocus(_focusNodePort);
        },
        textAlign: TextAlign.left,
        focusNode: _focusNodeClientID,
        autofocus: false,
        obscureText: false,
        enabled: registerAllow,
        controller: clientIDController,
        style: TextStyle(
            fontSize: fontSizes.baseFontSize, height: 1, color: Colors.black),
        decoration: InputDecoration(
          isDense: true,
          prefixIcon: Padding(
            padding: const EdgeInsets.only(left: 0),
            child: Icon(
              Icons.perm_identity,
              size: fontSizes.largerFontSize4,
              color: Colors.blue,
            ),
          ),
          fillColor: Colors.black,
          border: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.black, width: 5.00),
            borderRadius: BorderRadius.circular(2.0),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.blue),
            borderRadius: BorderRadius.circular(2.0),
          ),
          disabledBorder: OutlineInputBorder(
            borderSide: const BorderSide(color: Colors.red, width: 1.0), // Custom disabled border color
            borderRadius: BorderRadius.circular(2.0),
          ),
          labelText: ' CLIENT ID',
          labelStyle:
              TextStyle(color: Colors.black, fontSize: fontSizes.baseFontSize),
        ),
      ),
    );
  }

  Widget _activationBar() {
    return Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        child: TextFormField(
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9]')),
              LengthLimitingTextInputFormatter(6),
            ],
            onEditingComplete: () => FocusScope.of(context).nextFocus(),
            textAlign: TextAlign.left,
            focusNode: _focusNodeActivation,
            autofocus: false,
            obscureText: false,
            enabled: registerAllow,
            controller: activationController,
            style: TextStyle(
                fontSize: fontSizes.baseFontSize,
                height: 1,
                color: Colors.black),
            decoration: InputDecoration(
              isDense: true,
              prefixIcon: Padding(
                padding: EdgeInsets.only(left: 0),
                child: Icon(
                  Icons.key,
                  size: fontSizes.largerFontSize4,
                  color: Colors.blue,
                ),
              ),
              fillColor: Colors.white,
              border: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.black, width: 5.00),
                borderRadius: BorderRadius.circular(2.0),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.blue),
                borderRadius: BorderRadius.circular(2.0),
              ),
              disabledBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.red, width: 1.0), // Custom disabled border color
                borderRadius: BorderRadius.circular(2.0),
              ),
              labelText: ' ACTIVATION',
              labelStyle: TextStyle(
                  color: Colors.black, fontSize: fontSizes.baseFontSize),
            )));
  }

  Widget _requestBTN() {
    return InkWell(
      onTap: () async {
        if(apiData.actStatus == 'false' || apiData.actStatus.isEmpty) {
          if (secureStorageFlag == false) {
            Logger.log('ACTIVATION DATA NOT FOUND IN SYSTEM...',
                level: LogLevel.error);
            _addStatusMessage('ACTIVATION DATA NOT FOUND IN SYSTEM...');
            await _getActivationLogic();
            await _getSecureStorageData();
          } //NO DATA IN SECURE STORAGE
          else {
            if (isGenerated == true) {
              _apiHelper = ApiHelper();
              _apiHelper.initializeDio(
                  ipAddressController.text, portNoController.text);
              if (await _apiHelper.testConnectivity()) {
                _addStatusMessage('SERVER CONNECTED...');
                Map<String, dynamic> payload = {
                  "TERMINAL_SERIAL": apiData.clientID,
                  "RANDOM_ID": apiData.actCode,
                  "STATUS": apiData.actStatus.toString(),
                  "CREATED_DATE": apiData.dateTime != null &&
                      apiData.dateTime.isNotEmpty
                      ? apiData.dateTime
                      : _getCurrentDateTime(),
                  "UPDATED_DATE": _getCurrentDateTime(),
                };
                var result = await _apiHelper.updateTerminalDetailsTServer(
                    payload);
                setState(() {
                  writeToServer = true;
                });
                _addStatusMessage(result ?? 'NO RESULT FROM SERVER...');
              } else {
                _addStatusMessage('SERVER CONNECTION FAILED...');
              }
            }
            else {

            }
          } //DATA AVAILABLE IN SECURE STORAGE
        }
        else{
          _addStatusMessage('1 TERMINAL ACTIVATED. OPTION NOT AVAILABLE...');
          Logger.log('1 TERMINAL ACTIVATED. OPTION NOT AVAILABLE...', level: LogLevel.info);
        }
      },
      child: Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        decoration: BoxDecoration(
          borderRadius: const BorderRadius.all(Radius.circular(10)),
          color: isGenerated ? Colors.green : Colors.blue, // Change color when disabled
        ),
        child: Text(
          isGenerated ? 'REQUEST' : 'GENERATE',
          style: TextStyle(
            fontSize: fontSizes.baseFontSize,
            color: Colors.black,
          ),
        ),
      ),
    );
  }

  Widget _activate() {
    return InkWell(
      onTap: () async {
        if (apiData.actStatus == 'false' || apiData.actStatus=='') {
          _apiHelper = ApiHelper();
          _apiHelper.initializeDio(
              ipAddressController.text, portNoController.text);
          if (await _apiHelper.testConnectivity()) {
            _addStatusMessage('SERVER CONNECTED...');
            Map<String, dynamic> payload = {
              "TERMINAL_SERIAL": apiData.clientID,
              "RANDOM_ID": apiData.actCode,
            };
            // Fetch activation details from server
            var activationResult = await _apiHelper
                .getActivationDetailsFromServer(payload);
            if (activationResult != 'NA' && activationResult != 'ERROR') {
              _addStatusMessage('ACTIVATION DATA RECEIVED...');
              _addStatusMessage('PROCESSING ACTIVATION DATA...');
              formData['clientID'] = secureStorageclientID;
              formData['actCode'] = secureStorageactCode;
              String queryString = convertToQueryString(formData);
              String encryptedPayload = AES.encryptAES(queryString);
              if (activationResult == encryptedPayload) {
                // Prepare payload for updating terminal details
                Map<String, dynamic> updatePayload = {
                  "TERMINAL_SERIAL": apiData.clientID,
                  "RANDOM_ID": apiData.actCode,
                  "ACTIVATION_CODE": activationResult,
                  "STATUS": 'TRUE',
                  "UPDATED_DATE": _getCurrentDateTime(),
                  // Set to null initially
                  "ACTIVATED_DATE": _getCurrentDateTime()
                  // Set to null initially
                };
                // Call update terminal details
                var updateResult = await _apiHelper
                    .updateTerminalDetailsTServer(
                    updatePayload); // Renamed result to updateResult
                _addStatusMessage(updateResult!);
                Logger.log('DEVICE ACTIVATED...', level: LogLevel.info);
                _addStatusMessage('DEVICE ACTIVATED...');
                setState(() {
                  apiData.actStatus = 'true';
                  apiData.actAllow = 'false';
                  apiData.dateTime = _getCurrentDateTime();
                  apiData.actKey =
                  activationResult!; // Use activationResult instead of result
                });
                _addStatusMessage('SAVE DETAILS...');
                if (await saveData()) {
                  _loadDbData();
                }
              }
              else {
                setState(() {
                  apiData.actStatus = 'false';
                  apiData.actAllow = 'false';
                });
                Logger.log('ACTIVATION FAILED...', level: LogLevel.error);
                _addStatusMessage('ACTIVATION FAILED...');
              }
            } else {
              _addStatusMessage('ACTIVATION ERROR...');
            }
          } else {
            _addStatusMessage('SERVER CONNECTION FAILED...');
          }
        }
        else{

          if (await saveData()) {
            _loadDbData();
          }
          _addStatusMessage('2 TERMINAL ACTIVATED. OPTION NOT AVAILABLE...');
          Logger.log('2 TERMINAL ACTIVATED. OPTION NOT AVAILABLE...', level: LogLevel.info);
        }
        },
      child: Container(
        width: MediaQuery.of(context).size.width / 2.5,
        height: 50,
        alignment: Alignment.center,
        decoration: const BoxDecoration(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          color: Colors.indigoAccent,
        ),
        child: Text(
          'ACTIVATE',
          style: TextStyle(
            fontSize: fontSizes.baseFontSize,
            color: Colors.black,
          ), // Adjusted font size to match others
        ),
      ),
    );
  }

  Widget _messageBox(fontSizes) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: <Widget>[
        Container(
          padding: const EdgeInsets.all(10.0),
          width: MediaQuery.of(context).size.width / 2.25,
          height: MediaQuery.of(context).size.height / 2,
          // margin: const EdgeInsets.all(5),
          decoration: BoxDecoration(
            color: Colors.green,
            borderRadius: BorderRadius.circular(5.0),
            border: Border.all(
              color: Colors.white30,
              width: 1.0,
            ),
          ),
          child: Align(
            alignment: Alignment.topLeft,
            child: SingleChildScrollView(
              controller: _scrollController,
              scrollDirection: Axis.vertical,
              child: Column(
                crossAxisAlignment:
                    CrossAxisAlignment.start, // Ensure alignment to the start
                children: <Widget>[
                  for (var message in statusMessages)
                    Text(
                      message,
                      style: TextStyle(
                        fontFamily: fontFamily,
                        fontSize: fontSizes.smallerFontSize2,
                        fontStyle: FontStyle.normal,
                        color: Colors.black,
                      ),
                    ),
                ],
              ),
            ),
          ),
        )
      ],
    );
  }

  Widget _configBox() {
    return Container(
      padding: const EdgeInsets.all(10.0),
      width: MediaQuery.of(context).size.width / 2,
      height: MediaQuery.of(context).size.height / 2,
      margin: const EdgeInsets.all(5),
      decoration: BoxDecoration(
        color: Colors.transparent,
        borderRadius: BorderRadius.circular(5.0),
        border: Border.all(
          color: Colors.blueAccent,
          width: 1.0,
        ),
      ),
      child:  SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: <Widget>[
          Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              _imageScroll(),
              _videoScroll(),
              _textScroll(),
            ],
          ),
          Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              _enableLogo(),
              _enableBanner(),
            ],
          ),
          // if (_selectedScrollOption == 'IMAGE')
          Row(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Text(
            'IMAGE SCROLL : ',
            style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              fontWeight: FontWeight.bold,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.remove),
            onPressed: () => _decrement('image'),
            color: Colors.red,
            padding: EdgeInsets.zero, // Remove padding from IconButton
            constraints: const BoxConstraints(), // Remove default constraints
          ),
          const SizedBox(width: 10), // Space between button and text
          Text(
            '$_imgScrollDuration SEC',
            style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(width: 10), // Space between text and plus button
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () => _increment('image'),
            color: Colors.red,
            padding: EdgeInsets.zero, // Remove padding from IconButton
            constraints: const BoxConstraints(), // Remove default constraints
          ),
        ],
      ),
          Row(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Text(
            'PRICE DISPLAY : ',
            style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              fontWeight: FontWeight.bold,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.remove),
            onPressed: () => _decrement('price'),
            color: Colors.red,
            padding: EdgeInsets.zero, // Remove padding from IconButton
            constraints: const BoxConstraints(), // Remove default constraints
          ),
          const SizedBox(width: 10), // Space between button and text
          Text(
            '$_priceDisplayDuration SEC',
            style: TextStyle(
              fontSize: fontSizes.baseFontSize,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(width: 10), // Space between text and plus button
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () => _increment('price'),
            color: Colors.red,
            padding: EdgeInsets.zero, // Remove padding from IconButton
            constraints: const BoxConstraints(), // Remove default constraints
          ),
        ],
      ),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Text(
                'App Version : $appVersion',
                style: TextStyle(
                  fontSize: fontSizes.baseFontSize,
                  fontWeight: FontWeight.normal,
                  color: Colors.redAccent,
                ),
              ),
            ],
          ),
        ],
      ),
      ),
    );
  }

  Widget _enableLogo() {
    return Container(
      width: MediaQuery.of(context).size.width / 7.5,
      alignment: Alignment.center,
      child: CheckboxListTile(
        value: _logoCheck, // The current state (selected or not)
        onChanged: (bool? newValue) {
          setState(() {
            _logoCheck = newValue ?? false; // Toggle the selection
            apiData.logoEnable = _logoCheck.toString().toLowerCase();
          });
        },
        title: Text(
          'LOGO',
          style:
          TextStyle(fontSize: fontSizes.baseFontSize, color: Colors.blue),
        ),
        controlAffinity:
        ListTileControlAffinity.leading, // Checkbox on the left
        contentPadding: EdgeInsets.zero, // Remove extra padding
      ),
    );
  }

  Widget _enableBanner() {
    return Container(
      width: MediaQuery.of(context).size.width / 7.5,
      alignment: Alignment.center,
      child: CheckboxListTile(
        value: _bannerCheck, // The current state (selected or not)
        onChanged: (bool? newValue) {
          setState(() {
            _bannerCheck = newValue ?? false; // Toggle the selection
            apiData.bannerEnable = _bannerCheck.toString().toLowerCase();
          });
        },
        title: Text(
          'BANNER',
          style:
          TextStyle(fontSize: fontSizes.baseFontSize, color: Colors.blue),
        ),
        controlAffinity:
        ListTileControlAffinity.leading, // Checkbox on the left
        contentPadding: EdgeInsets.zero, // Remove extra padding
      ),
    );
  }

  Future<void> _getAppVersion() async {
    PackageInfo packageInfo = await PackageInfo.fromPlatform();
    setState(() {
      appVersion = '${packageInfo.version}.${packageInfo.buildNumber}';
    });
  }

  String? validateIpAddress(String? value) {
    // Regular expression to match valid IPv4 addresses
    const String pattern =
        r'^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])$';
    final RegExp regExp = RegExp(pattern);

    if (value == null || value.isEmpty) {
      return 'IP Address is required';
    } else if (!regExp.hasMatch(value)) {
      return 'Enter a valid IP Address';
    }
    return null; // Valid IP
  }

  Widget _imageScroll() {
    return Container(
      width: MediaQuery.of(context).size.width / 7.5,
      alignment: Alignment.center,
      child: RadioListTile<String>(
        value: 'IMAGE', // The value of this RadioListTile
        groupValue:
            _selectedScrollOption, // The currently selected option in the group
        onChanged: (String? newValue) {
          setState(() {
            _selectedScrollOption = newValue!;
            _imgScrollCheck = true;
            _videoScrollCheck = false;
          });
        },
        title: Text(
          'IMAGE',
          style:
              TextStyle(fontSize: fontSizes.baseFontSize, color: Colors.blue),
        ),
        controlAffinity: ListTileControlAffinity
            .leading, // Optional: position radio to the left
        contentPadding: EdgeInsets.zero, // Optional: remove extra padding
      ),
    );
  }

  Widget _videoScroll() {
    return Container(
      width: MediaQuery.of(context).size.width / 7.5,
      alignment: Alignment.center,
      child: RadioListTile<String>(
        value: 'VIDEO', // The value of this RadioListTile
        groupValue:
            _selectedScrollOption, // The currently selected option in the group
        onChanged: (String? newValue) {
          setState(() {
            _selectedScrollOption = newValue!;
            _imgScrollCheck = false;
            _videoScrollCheck = true;
          });
        },
        title: Text(
          'VIDEO',
          style:
              TextStyle(fontSize: fontSizes.baseFontSize, color: Colors.blue),
        ),
        controlAffinity: ListTileControlAffinity
            .leading, // Optional: position radio to the left
        contentPadding: EdgeInsets.zero, // Optional: remove extra padding
      ),
    );
  }

  Widget _textScroll() {
    return Container(
      width: MediaQuery.of(context).size.width / 7.5,
      alignment: Alignment.center,
      child: CheckboxListTile(
        value: _textScrollCheck, // The current state (selected or not)
        onChanged: (bool? newValue) {
          setState(() {
            _textScrollCheck = newValue ?? false; // Toggle the selection
          });
        },
        title: Text(
          'TEXT',
          style:
              TextStyle(fontSize: fontSizes.baseFontSize, color: Colors.blue),
        ),
        controlAffinity:
            ListTileControlAffinity.leading, // Checkbox on the left
        contentPadding: EdgeInsets.zero, // Remove extra padding
      ),
    );
  }

  void _addStatusMessage(String message) {
    String currentTime = DateFormat('hh:mm:ss a').format(DateTime.now());

    setState(() {
      statusMessages.add('$currentTime: $message');
    });

    Timer(const Duration(milliseconds: 100), () {
      if (_scrollController.hasClients) { // Check if the ScrollController is attached
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 100),
          curve: Curves.easeOut,
        );
      }
    });
  }

  Future<String> getAndroidMacAddress() async {
    final deviceInfoPlugin = DeviceInfoPlugin();
    try {
      final androidInfo = await deviceInfoPlugin.androidInfo;
      if(androidInfo.serialNumber!='unknown' && androidInfo.serialNumber!= null) {
        setState(() {
          actRandom = false;
        });
        Logger.log('SERIAL NUMBER OBTAINED ${androidInfo.serialNumber}', level: LogLevel.info);
        await _secureStorageService.writeData('clientID', androidInfo.serialNumber);
        return androidInfo.serialNumber;
      }else{
        Logger.log('CANNOT GET SERIAL NUMBER FROM TERMINAL. RANDOM NUMBER GENERATING.', level: LogLevel.warning);
        setState(() {
          actRandom = true;
        });
        var random = randomID(15);
        await _secureStorageService.writeData('clientID', random);
        return random;
      }
    } catch (e) {
      Logger.log('SERIAL NUMBER GENERATION FAILED. RANDOM NUMBER GENERATING.',
          level: LogLevel.error);
      setState(() {
        actRandom = true;
      });
      var random = randomID(15);
      await _secureStorageService.writeData('clientID', random);
      return random;
    }
  }

  String randomID(int length) {
    const String chars =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    Random random = Random();
    setState(() {
      actRandom = true;
    });
    return List.generate(length, (index) => chars[random.nextInt(chars.length)])
        .join();
  }

  bool validateSysConfigData() {
    if (ipAddressController.text != null && ipAddressController.text != '') {
      if (portNoController.text != null && portNoController.text != '') {
        if (currencyCodes != null && currencyCodes != '') {
          if (voiceCodes != null && voiceCodes != '') {
            if (clientIDController.text != null && clientIDController.text != '') {
              if (activationController.text != null && activationController.text != '') {
                return true;
              } else {
                _addStatusMessage('ACTIVATION CODE IS NOT VALID...');
                Logger.log('ACTIVATION CODE IS NOT VALID...', level: LogLevel.error);
              }
            } else {
              _addStatusMessage('CLIENT ID IS NOT VALID...');
              Logger.log('CLIENT ID IS NOT VALID...', level: LogLevel.error);
            }
          } else {
            _addStatusMessage('VOICE CODE IS NOT VALID...');
            Logger.log('VOICE CODE IS NOT VALID...', level: LogLevel.error);
          }
        } else {
          _addStatusMessage('CURRENCY CODE IS NOT VALID...');
          Logger.log('CURRENCY CODE IS NOT VALID...', level: LogLevel.error);
        }
      } else {
        _addStatusMessage('PORT NUMBER IS NOT VALID...');
        Logger.log('PORT NUMBER IS NOT VALID...', level: LogLevel.error);
      }
    } else {
      _addStatusMessage('IP ADDRESS IS NOT VALID...');
      Logger.log('IP ADDRESS IS NOT VALID...', level: LogLevel.error);
    }
    return false;
  }

  Future<void> _loadDbData() async {
    // Use the previously retrieved secure storage values
    if (secureStorageFlag == false) {
      Logger.log('SECURE STORAGE DATA NOT EXISTS...', level: LogLevel.error);
      _addStatusMessage('SECURE STORAGE DATA NOT EXISTS...');
      await dbProvider.deleteApiData();
      Logger.log('CLEARING LOCAL DB...', level: LogLevel.error);
      _addStatusMessage('CLEARING LOCAL DB...');
      Logger.log('PLEASE FILL ALL DETAILS...', level: LogLevel.error);
      _addStatusMessage('PLEASE FILL ALL DETAILS...');
    }//NO DATA IN SECURE STORAGE
    else{
      // Get the API data from the database
      apiData = (await dbProvider.getApiData()) ?? apiData;
      if(apiData.clientID == secureStorageclientID && apiData.actCode == secureStorageactCode){
        if(apiData.actStatus == 'true'){
          setState(() {
            clientIDController.text = apiData.clientID = secureStorageclientID;
            activationController.text = apiData.actCode = secureStorageactCode;
            apiData.actAllow = 'false';
            isGenerated = true;
            ipAddressController.text = apiData.serverIP;
            portNoController.text = apiData.portNo;
            _selectedCurrency = apiData.currency;
            _selectedVoice = apiData.voice;
            _imgScrollCheck = apiData.imageScroll.toLowerCase() == 'true';
            _videoScrollCheck = apiData.videoScroll.toLowerCase() == 'true';
            _textScrollCheck = apiData.textScroll.toLowerCase() == 'true';
            _imgScrollDuration = int.tryParse(apiData.imageDisplay) ?? 5;
            _priceDisplayDuration = int.tryParse(apiData.priceDisplay) ?? 3;
            _logoCheck = apiData.logoEnable.toLowerCase() == 'true';
            _bannerCheck = apiData.bannerEnable.toLowerCase() == 'true';
            if (_imgScrollCheck) {
              _selectedScrollOption = 'IMAGE';
            }
            if (_videoScrollCheck) {
              _selectedScrollOption = 'VIDEO';
            }
            if (_textScrollCheck) {
              Logger.log(
                  'TEXT SCROLL = $_textScrollCheck', level: LogLevel.info);
            }
          });
        }
      }//ACTIVATION VERIFIED, LOAD DATA
      else{
        Logger.log('CLEARING LOCAL DB...', level: LogLevel.error);
        _addStatusMessage('CLEARING LOCAL DB...');
        await dbProvider.deleteApiData();
        setState(() {
          apiData.clientID = clientIDController.text = secureStorageclientID;
          apiData.actCode = activationController.text = secureStorageactCode;
          apiData.actStatus = 'false';
          apiData.actAllow = 'false';
          isGenerated = true;
          registerAllow = false;
        });
      }

    }//DATA FOUND IN SECURE STORAGE
  }

  void _increment(String type) {
    setState(() {
      if (type == 'image') {
        _imgScrollDuration++;
      } else if (type == 'price') {
        _priceDisplayDuration++;
      }
    });
  }

  void _decrement(String type) {
    setState(() {
      if (type == 'image') {
        if (_imgScrollDuration > 1) _imgScrollDuration--;
      } else if (type == 'price') {
        if (_priceDisplayDuration > 1) _priceDisplayDuration--;
      }
    });
  }

  String convertToQueryString(Map<String, dynamic> data) {
    List<String> queryParameters = [];

    data.forEach((key, value) {
      // Convert the value to a string without replacing spaces
      String formattedValue = value.toString();
      queryParameters.add('$key=$formattedValue');
    });
    // Join the parameters with '&' and return the query string
    return queryParameters.join('&');
  }

  String convertToJsonString(String trandata) {
    // Create a map with the required structure
    // trandata = '0CE90F34CBE341598BC0BD7D6269167E62D490E2C9669AE1CE64ACEF1D0856512B36A01523130DAAD080DF8C128DA34B2DBED6A3B6B25233C359CC0890CB523C96EA730DC65C1A47E5015B9D52673673530024D05EDA7B98DFDADAAE928E9CEA1DC48507FF2BBEA81ABA677F8082726E3A7E2DEC4B0281AAC536EEA30595E0613BC45D0EEEE16FABD5596B24114AB7CDCEA78869714674DE061FE77B3622C14964D9C4C6BEF03AAA15498B5890DC7E7666AD079408538DC5CB0729CAD427AD30';
    Map<String, dynamic> data = {
      'trandata': trandata,
    };
    return jsonEncode([data]);
    // Convert the map to a JSON string
    // String jsonString = jsonEncode([data]);
    // Pretty-print the JSON
    // var jsonPrettyPrint = JsonEncoder.withIndent('  '); // Indent with 2 spaces
    // print(jsonPrettyPrint);
    // return jsonPrettyPrint.convert(jsonDecode(jsonString));
  }

  // Function to convert query string to JSON format
  Map<String, String> convertQueryStringToJson(String queryString) {
    final Map<String, String> data = {};
    queryString.split('&').forEach((element) {
      var pair = element.split('=');
      if (pair.length == 2) {
        data[pair[0]] = pair[1];
      }
    });

    return data;
  }

  Future<bool> _getActivationLogic() async{
    try {
      clientIDController.text = await getAndroidMacAddress();
      int idLength = 30 - (clientIDController.text).length;
      var actValue = randomID(idLength);
      await _secureStorageService.writeData('actCode', actValue);
      activationController.text = actValue;
      formData['clientID'] = clientIDController.text;
      formData['actCode'] = activationController.text;
      String queryString = convertToQueryString(formData);
      String payload = AES.encryptAES(queryString);
      String decryptData = AES.decryptAES(payload);
      Map<String, String> jsonMap = convertQueryStringToJson(decryptData);
      String jsonOutput = jsonEncode(jsonMap);
      Logger.log('ENCRYPTED DATA: $payload', level: LogLevel.info);
      Logger.log('DECRYPTED DATA: $decryptData', level: LogLevel.info);
      Logger.log('JSON OUTPUT: $jsonOutput', level: LogLevel.info);
      setState(() {
        isGenerated = true;
        apiData.clientID = formData['clientID']!;
        apiData.actCode = formData['actCode']!;
        apiData.actAllow = 'false';
        registerAllow ? "1" : "0"; // Assigns "1" if true, "0" if false
        apiData.actKey = payload;
      });
      _addStatusMessage('TERMINAL SERIAL GENERATED...');
      Logger.log('TERMINAL SERIAL GENERATED...', level: LogLevel.debug);
      return true;
    }catch(e){
      setState(() {
        isGenerated = false;
      });
      _addStatusMessage('KEY VALUE GENERATION ERROR...${e.toString()}');
      Logger.log('KEY VALUE GENERATION ERROR...${e.toString()}', level: LogLevel.error);
      return false;
    }
  }

  void scaffoldMsg(BuildContext context, String msg, fontSizes) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Container(
          width: MediaQuery.of(context).size.width * 0.8, // 80% of the screen width
          alignment: Alignment.center,
          child: Text(
            msg.toString(),
            style: TextStyle(
              color: Colors.white,
              fontSize: fontSizes.smallerFontSize4,
            ),
            textAlign: TextAlign.center,
          ),
        ),
        duration: const Duration(seconds: 2),
        backgroundColor: Colors.blue,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(10),
        ),
        margin: EdgeInsets.symmetric(
          horizontal: MediaQuery.of(context).size.width * 0.1, // Center it by adding side margins
          vertical: 20,
        ), // Optional, to control vertical margin
      ),
    );
  }

  String _getCurrentDateTime() {
      final now = DateTime.now();
      return "${now.year.toString().padLeft(4, '0')}-"
          "${now.month.toString().padLeft(2, '0')}-"
          "${now.day.toString().padLeft(2, '0')} "
          "${now.hour.toString().padLeft(2, '0')}:"
          "${now.minute.toString().padLeft(2, '0')}:"
          "${now.second.toString().padLeft(2, '0')}";
  }

  Future<bool> saveData() async {
    if (!validateSysConfigData()) {
      _addStatusMessage('ALL INPUTS ARE MANDATORY...');
      Logger.log('ALL INPUTS ARE MANDATORY...', level: LogLevel.info);
      return false;
    }
    setState(() {
      apiData.serverIP = ipAddressController.text;
      apiData.portNo = portNoController.text;
      apiData.currency = _selectedCurrency ?? '';
      apiData.voice = _selectedVoice ?? '';
      // apiData.clientID = clientIDController.text;
      apiData.actCode = activationController.text;
      apiData.priceDisplay = _priceDisplayDuration.toString();
      apiData.imageDisplay = _imgScrollDuration.toString();
      apiData.imageScroll = _imgScrollCheck.toString();
      apiData.videoScroll = _videoScrollCheck.toString();
      apiData.textScroll = _textScrollCheck.toString();
      // apiData.actStatus = actStatus.toString();
      // apiData.actKey = '';
      // apiData.actAllow = 'false';
      apiData.dateTime = _getCurrentDateTime();
    });

    // Ensure all required fields are populated
    if (_areAllFieldsPopulated()) {
      _addStatusMessage('SAVING DATA TO DATABASE...');
      Logger.log('SAVING DATA TO DATABASE...', level: LogLevel.info);

      // Save data to the database
      bool isSaved = await dbProvider.insertApiData(apiData);
      if (isSaved) {
        _addStatusMessage('DATA SAVED...');
        Logger.log('DATA SAVED...', level: LogLevel.info);
        return true;
      } else {
        _addStatusMessage('ERROR SAVING DATA TO DATABASE...');
        Logger.log('ERROR SAVING DATA TO DATABASE...', level: LogLevel.error);
        return false;
      }
    } else {
      _addStatusMessage('PLEASE FILL ALL REQUIRED FIELDS...');
      Logger.log('PLEASE FILL ALL REQUIRED FIELDS...', level: LogLevel.info);
      return false;
    }
  }

  bool _areAllFieldsPopulated() {
    if (apiData.serverIP.isEmpty) {
      _addStatusMessage('SERVER IP IS NOT POPULATED...');
      Logger.log('SERVER IP IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.portNo.isEmpty) {
      _addStatusMessage('PORT NUMBER IS NOT POPULATED...');
      Logger.log('PORT NUMBER IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.currency.isEmpty) {
      _addStatusMessage('CURRENCY CODE IS NOT POPULATED...');
      Logger.log('CURRENCY CODE IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.voice.isEmpty) {
      _addStatusMessage('VOICE CODE IS NOT POPULATED...');
      Logger.log('VOICE CODE IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.clientID.isEmpty) {
      _addStatusMessage('CLIENT ID IS NOT POPULATED...');
      Logger.log('CLIENT ID IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.actCode.isEmpty) {
      _addStatusMessage('ACTIVATION CODE IS NOT POPULATED...');
      Logger.log('ACTIVATION CODE IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.priceDisplay.isEmpty) {
      _addStatusMessage('PRICE DISPLAY IS NOT POPULATED...');
      Logger.log('PRICE DISPLAY IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.imageDisplay.isEmpty) {
      _addStatusMessage('IMAGE DISPLAY IS NOT POPULATED...');
      Logger.log('IMAGE DISPLAY IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.imageScroll.isEmpty) {
      _addStatusMessage('IMAGE SCROLL IS NOT POPULATED...');
      Logger.log('IMAGE SCROLL IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.videoScroll.isEmpty) {
      _addStatusMessage('VIDEO SCROLL IS NOT POPULATED...');
      Logger.log('VIDEO SCROLL IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.textScroll.isEmpty) {
      _addStatusMessage('TEXT SCROLL IS NOT POPULATED...');
      Logger.log('TEXT SCROLL IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.actStatus.isEmpty) {
      _addStatusMessage('ACTIVATION STATUS IS NOT POPULATED...');
      Logger.log('ACTIVATION STATUS IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.actKey.isEmpty) {
      _addStatusMessage('ACTIVATION KEY IS NOT POPULATED...');
      Logger.log('ACTIVATION KEY IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.actAllow.isEmpty) {
      _addStatusMessage('ACTIVATION ALLOWANCE IS NOT POPULATED...');
      Logger.log('ACTIVATION ALLOWANCE IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }
    if (apiData.dateTime.isEmpty) {
      _addStatusMessage('DATE AND TIME IS NOT POPULATED...');
      Logger.log('DATE AND TIME IS NOT POPULATED...', level: LogLevel.info);
      return false;
    }

    Logger.log('SAVING DATA TO DATABASE...', level: LogLevel.info);
    _addStatusMessage('SAVING DATA TO DATABASE...');
    return true;
  }

  @override
  Widget build(BuildContext context) {
    fontSizes = FontSizes.fromContext(context);
    return Scaffold(
      body: SingleChildScrollView(
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 20),
          width: MediaQuery.of(context).size.width,
          color: Colors.white,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            mainAxisAlignment: MainAxisAlignment.start,
            children: <Widget>[
              SizedBox(
                height: MediaQuery.of(context).size.height / 250,
              ),
              _title(),
              SizedBox(
                height: MediaQuery.of(context).size.height / 150,
              ),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                mainAxisAlignment: MainAxisAlignment.start,
                children: <Widget>[
                  Expanded(
                    flex: 2,
                    child: _ipAddress(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 2,
                    child: _portNo(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 1,
                    child: _testButton(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 1,
                    child: _saveButton(),
                  ),
                ],
              ),
              SizedBox(
                height: MediaQuery.of(context).size.height / 50,
              ),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                mainAxisAlignment: MainAxisAlignment.start,
                children: <Widget>[
                  Expanded(
                    flex: 2,
                    child: _currencyDropdown(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 2,
                    child: _voiceDropdown(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 1,
                    child: _initButton(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 1,
                    child: _resetButton(),
                  ),
                ],
              ),
              SizedBox(height: MediaQuery.of(context).size.height / 50),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                mainAxisAlignment: MainAxisAlignment.start,
                children: <Widget>[
                  Expanded(
                    flex: 2,
                    child: _clientID(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 2,
                    child: _activationBar(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 1,
                    child: _requestBTN(),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    flex: 1,
                    child: _activate(),
                  ),
                ],
              ),
              SizedBox(
                height: MediaQuery.of(context).size.height / 50,
              ),
              Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: <Widget>[
                    Expanded(
                      flex: 3,
                      child: _messageBox(fontSizes),
                    ),
                    Expanded(
                      flex: 3,
                      child: _configBox(),
                    ),
                  ]),
            ],
          ),
        ),
      ),
    );
  }
}